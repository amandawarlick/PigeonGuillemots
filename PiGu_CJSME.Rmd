
# Following example code from Kery & Schaub, implementing Conn & Cooch 2009

```{r}

library(rjags)
#library(R2jags) #seems to fight with jagsUI
library(jagsUI)
library(R2OpenBUGS)
library(dplyr)
library(tidyr)
library(reshape2)

setwd("~/Documents/SAFS/PigeonGuillemots")


```

```{r}
#load data from PigeonGuillemot_whidbey.Rmd
data_burrow_all <- read.csv("data_burrow.csv", header = T, stringsAsFactors = F) %>%
  select(-intern_data)

#study start day per year, island-wide
start_end_all <- data_burrow_all %>%
  group_by(year, region) %>%
  summarize(start_day = min(yday), end_day = max(yday))

burrow <- data_burrow_all %>%
  distinct() %>%
  select(-c(Gunnel, Sculpin, Other)) %>%
  merge(start_end_all, by = c('region', 'year'), all = T) %>%
  transform(study_day = yday - start_day + 1)  

dup_test <- burrow[duplicated(burrow),]

#data frame of burrow-site-year combinations with no prey deliveries and 0 or 1 burrow visit
#could be failed nest attempts, but could also be mistaken landings? 7/2018 Whidbey visit - Frances guesses these are probably birds going into potential burrows and then not using them, so should be excluded
# exclusions <- burrow %>%
#   group_by(region, burrow_name, year, site) %>%
#   summarize(cnt_pv = sum(tot_prey)) %>%
#   filter(cnt_pv < 1) %>%
#   merge(burrow, by = c('region', 'burrow_name', 'year', 'site'), all = F) %>%
#   group_by(region, burrow_name, year, site, date, week, yday) %>%
#   summarize(cnt_bv = sum(burrow_visit)) %>%
#   filter(cnt_bv < 2) %>%
#   transform(exclude = "Y") %>%
#   select(region, burrow_name, year, site, date, week, yday)

#burrow visit and prey visit start stops
prey_start_end <- burrow %>%
  filter(tot_prey > 0) %>%
  group_by(region, year, site, burrow_name) %>%
  summarize(prey_start = min(study_day), prey_end = max(study_day))  

bv_start_end <- burrow %>%
  filter(burrow_visit > 0) %>%
  group_by(region, year, site, burrow_name) %>%
  summarize(bv_start = min(study_day), bv_end = max(study_day))  

start_end_visits <- prey_start_end %>%
  merge(bv_start_end, by = c('region', 'year', 'site', 'burrow_name'), all = T)
# no_start <- start_end_visits %>%  #45% 8/1/18
#   filter(prey_start > bv_start | is.na(bv_start)) %>% nrow()/nrow(start_end_visits)
# no_end <- start_end_visits %>% #6% 8/1/18
#   filter(prey_end == bv_start) %>% nrow()/nrow(start_end_visits)

#df of all days to merge into actual observations below
all_days <- data.frame(seq(1:81))
names(all_days) <- 'study_day'
 
burrow_1 <- burrow %>%
  select(region, site, year, date, yday, study_day, start_day, end_day, burrow_name, burrow_visit, tot_prey) %>%
  select(-c(start_day, end_day, date, yday))  

burrow_2 <- burrow_1 %>%
  distinct(region, year, site, burrow_name) %>%
  filter(!is.na(burrow_name)) %>% #remnant of merging on count dates where no visits
  merge(all_days, all = T)  

burrow_day_CH <- burrow_2 %>%
  merge(burrow_1, by = c('region', 'site', 'year', 'burrow_name', 'study_day'), all.x = T) %>%
  merge(start_end_visits, by = c('region', 'year', 'site', 'burrow_name'), all.x = T) %>%
  transform(prey_days = prey_end + 1 - prey_start) %>%
  transform(bv_days = bv_end + 1 - bv_start) %>%
  #filter(!is.na(burrow_name)) %>% #remnant of merging on count dates where no visits
  transform(capt_hist =
              ifelse(is.na(burrow_visit) & is.na(tot_prey), 3, #not seen
                     ifelse(burrow_visit == 0 & tot_prey == 0, 3, #not seen
              ifelse(tot_prey > 0, 2,#nestling
              ifelse(burrow_visit > 0, 1, #egg
                       100))))) 

test <- burrow_day_CH %>%
  #filter(capt_hist == 100)
  #filter(capt_hist != 'NA')
  filter(is.na(capt_hist))
hist(burrow_day_CH$capt_hist)
table(burrow_day_CH$capt_hist)

dup_test <- burrow_day_CH[duplicated(burrow_day_CH),]


data_ME_day <- burrow_day_CH %>%
  select(region, year, site, study_day, burrow_name, capt_hist) %>%
  distinct()
 
test <- data_ME_day[duplicated(data_ME_day),]

```


```{r}

data_ME_day_wide <- data_ME_day %>% 
  distinct(region, year, site, burrow_name, study_day, capt_hist) %>% 
  dcast(region + year + site + burrow_name ~ study_day, value.var = 'capt_hist', fill = 3, fun.aggregate = mean)

CH_PG_day <- as.matrix(data_ME_day_wide %>% select(-c(region, year, site, burrow_name)), rownames.force = F)
colnames(CH_PG_day) <- NULL
CH_PG_day <- round(CH_PG_day, 0)

#data_ME_day_small <- data_ME_day_wide[sample(nrow(data_ME_day_wide), 300),]
#CH_PG_day_small <- as.matrix(data_ME_day_small %>% select(-c(region, year, site, burrow_name)), rownames.force = F)
#colnames(CH_PG_day_small) <- NULL

```

```{r}

# Specify model in jags

model_ME <- function () {

# -------------------------------------------------
# Parameters:
# phiA: survival probability from egg to nestling
# phiB: survival probability from nestling to fledge
# psiAB: probability of transitioning from egg to nestling
# psiBA: probability of transitioning from nestling to egg
# pA: recapture probability of eggs
# pB: recapture probability of nestling
# b: probability that a PV is not detected 
# pi: probability that an individual is an egg when marked 
  
# -------------------------------------------------
# States (S):
# 1 alive as an egg
# 2 alive as a nestling
# 3 dead or fledged
# Observations (O):  
# 1 observed as an egg 
# 2 observed as a nestling (PV)
# 3 not observed
# -------------------------------------------------

# Priors and constraints
for (i in 1:nind){
   for (t in 1:(n.occasions-1)){
      phiA[i,t] <- mean.phi[1]
      phiB[i,t] <- mean.phi[2]
      psiAB[i,t] <- mean.psi
      pA[i,t] <- mean.p[1]
      pB[i,t] <- mean.p[2]
      b[i,t] <- mean.b
      pi[i,t] <- mean.pi
      } # t
   } # i

for (u in 1:2){
   mean.phi[u] ~ dunif(0, 1)    # Priors for mean state-spec. survival
   mean.p[u] ~ dunif(0, 1)      # Priors for mean state-spec. recapture
}
mean.psi ~ dunif(0, 1)    # Priors for mean transition
mean.b ~ dunif(0, 1)  # Prior for mean assignment error
mean.pi ~ dunif(0, 1)

# Define transition and observation matrices
for (i in 1:nind){
   for (t in f[i]:(n.occasions-1)){
      # Define state probability when an individual is marked
      pj[i,t,1] <- pi[i,t]
      pj[i,t,2] <- 1-pi[i,t]
      
      # Define probabilities of O(t) given S(t) at the occasion of marking 
      po1[1,i,t,1] <- 1
      po1[1,i,t,2] <- 0
      po1[1,i,t,3] <- 0
      po1[2,i,t,1] <- b[i,t]
      po1[2,i,t,2] <- 1-b[i,t]
      po1[2,i,t,3] <- 0
      po1[3,i,t,1] <- 0
      po1[3,i,t,2] <- 0
      po1[3,i,t,3] <- 1
      
      # Define probabilities of state S(t+1) given S(t)   
      ps[1,i,t,1] <- phiA[i,t] * (1-psiAB[i,t]) #survival of egg * probability of not transitioning
      ps[1,i,t,2] <- phiA[i,t] * psiAB[i,t] #survival of egg * probability of transitioning
      ps[1,i,t,3] <- 1 - phiA[i,t]  #egg terminates
      ps[2,i,t,1] <- phiB[i,t] * 0  #nestling can't become an egg
      ps[2,i,t,2] <- phiB[i,t] * 1 #survival of nestling * prob of not transitioning nestling -> egg 
      ps[2,i,t,3] <- 1 - phiB[i,t] #nestling terminates
      ps[3,i,t,1] <- 0 #terminated can't go backwards
      ps[3,i,t,2] <- 0 #terminated can't go backwards
      ps[3,i,t,3] <- 1 #terminated stays dead
      
      # Define probabilities of O(t) given S(t)
      po[1,i,t,1] <- pA[i,t]  #egg detection probability
      po[1,i,t,2] <- 0  #can't be observed getting PV if an egg
      po[1,i,t,3] <- 1 - pA[i,t]  #probability of not detecting egg
      po[2,i,t,1] <- b[i,t] * pB[i,t] #probability of missing PV * probability of detecting nestling
      po[2,i,t,2] <- (1 - b[i,t]) * pB[i,t] #probability of detecting PV * nestling detection probability
      po[2,i,t,3] <- 1 - pB[i,t]  #prob of not observing nestling 
      po[3,i,t,1] <- 0 
      po[3,i,t,2] <- 0
      po[3,i,t,3] <- 1 #prob of not detecting a terminated nest
      } #t
   } #i
 
# Likelihood 
for (i in 1:nind){
   # Define latent state at first capture
   z[i,f[i]] ~ dcat(pj[i, f[i],])
   y[i,f[i]] ~ dcat(po1[z[i,f[i]], i, f[i], ])
   for (t in (f[i]+1):n.occasions){
      # State process: S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], i, t-1,])
      # Observation process: O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], i, t-1,])
      } #t
   } #i
}
write.model(model_ME, "model_ME.txt")
model.file = paste(getwd(),"model_ME.txt", sep="/")

#ch <- CH_PG_day

# Function to fill in known z state (reduce computation time)
me.known.z <- function(ch) {
  known.z <- ch
  for (i in 1:dim(known.z)[1]) {
    if (sum(known.z[i,] == 2) < 1) {  #If there aren't any prey deliveries, all NA
       known.z[i,] <- NA
     } else {
    known_first <- min(which(ch[i,] == 2)) #first prey delivery
    known_last <- max(which(ch[i,] == 2)) #last prey delivery
    known.z[i, known_first:known_last] <- 2 #all days between first and last represent known state 2
     }
  }
  known.z[known.z == 1] <- NA  #unknown states when observations are bv or not seen
  known.z[known.z == 3] <- NA
  return(known.z)
}

# Function to create initial values for unknown z; explained on pg 181-2 of BPA
me.init.z <- function(ch, f){
  inits <- ch
   for (i in 1:dim(ch)[1]) { 
     if (sum(inits[i,] == 2) < 1) {   #If no prey deliveries, 3s
       inits[i, (f[i]+1):dim(ch)[2]] <- rep(3, (dim(ch)[2]-f[i]))
       inits[i,1:f[i]-1] <- NA  #NAs before first capture
     } else {
    prey_first <- min(which(ch[i,] == 2)) #first prey delivery
    prey_last <- max(which(ch[i,] == 2)) #last prey delivery
    bv_first <- min(which(ch[i,] == 1))
    inits[i, prey_first:prey_last] <- NA #NAs between first and last prey delivery
    inits[i, (prey_last+1):(dim(ch)[2])] <- sample(2:3, (dim(ch)[2])-prey_last, replace = T) #2s and 3s after last prey
    inits[i,1:f[i]-1] <- NA  #NAs before first capture
    # if (bv_first < prey_first) {  #if there is a PV but first capture is a BV...
    #       inits[i, (bv_first+1):(prey_first-1)] <- sample(1:2, prey_first-bv_first, replace = T) #1s/2s before first prey
    #     }
      }
    }
  return(inits)
}

get.first <- function(x) min(which(x != 3))
f <- apply(CH_PG_day, 1, get.first)

#looking for troubling 'inf' results of get.first
#which(f > 1000) 

# get.last <- function(x) max(which(x != 3))
# last <- apply(CH_PG_day_small, 1, get.last)

# Bundle data
jags.data <- list(y = CH_PG_day, 
                  f = f, 
                  n.occasions = dim(CH_PG_day)[2], 
                  nind = dim(CH_PG_day)[1],
                  z = me.known.z(CH_PG_day))

# Initial values - no mean.b?
inits <- function(){list(mean.phi = runif(2, 0, 1),
                         #mean.psi = runif(2, 0, 1),
                         mean.p = runif(2, 0, 1),
                         z = me.init.z(CH_PG_day, f))}
 
# Parameters
parameters <- c("mean.phi", "mean.psi", "mean.p", "mean.b", "mean.pi")

# MCMC settings
nc <- 3; nAdapt <- 100; nb <- 200; ni <- 500 + nb; nt <- 1  

#jags
me <- jags(jags.data, 
           inits, 
           parameters.to.save = parameters, n.chains = nc, model.file = model.file,
           n.adapt = nAdapt, n.thin = nt, n.iter = ni, n.burnin = nb, parallel = T)

print(me, digits = 3)

```

```{r}

get.first.pv <- function(x) min(which(x == 2))
first_pv <- apply(CH_PG_day, 1, get.first.pv)

get.first.bv <- function(x) min(which(x == 1))
first_bv <- apply(CH_PG_day, 1, get.first.bv)

get.last.pv <- function(x) max(which(x == 2))
last_pv <- apply(CH_PG_day, 1, get.last.pv)

get.last.bv <- function(x) max(which(x == 1))
last_bv <- apply(CH_PG_day, 1, get.last.bv)

par(mfrow = c(2, 2), mar = c(5, 4, 2, 1), cex.lab = 1, cex.axis = .8)
hist(first_pv, breaks = 81, main = '') 
hist(first_bv, breaks = 81, main = '') 
hist(last_pv, breaks = 81, main = '') 
hist(last_bv, breaks = 81, main = '') 

#as.data.frame(table(first_pv))

pv_minmax <- data_ME_day %>%
  filter(capt_hist == 2) %>%
  group_by(region, year, site, burrow_name) %>%
  summarize(min_pv = min(study_day), max_pv = max(study_day))

bv_minmax <- data_ME_day %>%
  filter(capt_hist == 1) %>%
  group_by(region, year, site, burrow_name) %>%
  summarize(min_bv = min(study_day), max_bv = max(study_day))

minsmax <- pv_minmax %>%
  bind_rows(bv_minmax) %>%
  melt(id.vars = c('region', 'year', 'site', 'burrow_name'))

by_year <- ggplot(minsmax, aes(factor(year), value), color = variable) +
  geom_boxplot() + facet_wrap(~variable) +
  xlab("") + ylab("Study Day") + 
  fig_theme()

by_site <- ggplot(minsmax %>% 
                   filter(grepl("pv", variable) & value != 'NA' & region == 'Whidbey'), 
                 aes(site, value, group = site, color = site)) +
  geom_boxplot() + 
  facet_wrap(~variable) +
  xlab("") + ylab("Study Day") +
  fig_theme(legend.position = 'none')

by_reg <- ggplot(minsmax %>% 
                   filter(value != 'NA'), 
                 aes(region, value, group = region, color = variable)) +
  geom_boxplot() + 
  facet_wrap(~variable) +
  xlab("") + ylab("Study Day") +
  fig_theme(legend.position = 'none') +
  scale_color_manual(values = c("#3b98ee", "#a3d39c", "#e45f56", "#f6b61c"))

density <- ggplot(data = data_ME_day, aes(study_day)) +
  geom_line(data = data_ME_day %>% filter(capt_hist == 1), aes(study_day, col = 'BV'), 
            stat = 'density') + 
  geom_line(data = data_ME_day %>% filter(capt_hist == 2), aes(study_day, col = 'PV'), 
            stat = 'density') + 
  geom_vline(aes(xintercept = 40), linetype = 'dotted', col = 'darkgrey') +
  geom_vline(aes(xintercept = 20), linetype = 'dotted', col = 'darkgrey') +
  scale_y_continuous(limit = c(0, 0.025)) +
  ylab("Relative Frequency Density") + xlab("") + facet_wrap(~region) +
  scale_color_manual(values = c("#e45f56", "#363e7e")) +
  fig_theme()


# capt_hist_day <- ggplot(data_ME_day %>% filter(region == 'Whidbey' & capt_hist < 3), 
#                 aes(y = capt_hist, x = study_day)) +
#                 geom_point(position = 'jitter')

```

```{r}

# Function to simulate multistate capture-recapture data for a model where the disease may not always be seen; from Kery & Schaub BPA

simul.me <- function(PSI.STATE, PSI.OBS, PSI.INI, OBS.INI, marked, unobservable = NA){
   # Unobservable: number of state that is unobservable
   n.occasions <- dim(PSI.STATE)[4] + 1
   CH <- CH.TRUE <- matrix(NA, ncol = n.occasions, nrow = sum(marked))
   # Define a vector with the occasion of marking
   mark.occ <- rep(1:length(marked), marked)
   
   for (i in 1:sum(marked)){
      # Initial state
      CH.TRUE[i,mark.occ[i]] <- which(rmultinom(1, 1, PSI.INI[,i,mark.occ[i]])==1)
      CH[i,mark.occ[i]] <- which(rmultinom(1, 1, OBS.INI[CH.TRUE[i,mark.occ[i]],,i,mark.occ[i]])==1)
      for (t in (mark.occ[i]+1):n.occasions){
         # Multinomial trials for state transitions
         if (mark.occ[i]==n.occasions) next
         state <- which(rmultinom(1, 1, PSI.STATE[CH.TRUE[i,t-1],,i,t-1])==1)
         CH.TRUE[i,t] <- state
         # Multinomial trials for observation process
         event <- which(rmultinom(1, 1, PSI.OBS[CH.TRUE[i,t],,i,t-1])==1)
         CH[i,t] <- event
         } #t
      } #i
   # Replace the NA and the highest state number (dead) in the file by 0
   CH[is.na(CH)] <- 0
   CH[CH==dim(PSI.OBS)[2]] <- 0
   CH[CH==unobservable] <- 0
   id <- numeric(0)
   for (i in 1:dim(CH)[1]){
      z <- min(which(CH[i,]!=0))
      ifelse(z==dim(CH)[2], id <- c(id,i), id <- c(id))
      }
   return(list(CH=CH[-id,], CH.TRUE=CH.TRUE[-id,]))
   # CH: capture histories to be used
   # CH.TRUE: capture histories with perfect observation
   }

# Define mean survival, transitions, recapture, as well as number of occasions, states, observations and released individuals
phiA <- 0.8  # survival from egg - egg hatches
phiB <- 0.6  # survival of nestling
psiAB <- 0.5 # probability of transitioning from egg to nestling, conditional on survival
psiBA <- 0   # probability of transitioning from nestling to egg
pA <- 0.7    # recapture probability of egg
pB <- 0.5    # recapture probability of nestling
b <- 0.3     # probability that a PV is not detected
psi <- 0.75  # probability that an individual is an egg when marked 

n.occasions <- 75
n.states <- 3
n.obs <- 3
marked <- c(rep(10, 4), rep(15, 4), rep(5, 32), rep(1, 35))  

# Define matrices with survival, transition and recapture probabilities
# These are 4-dimensional matrices, with 
   # Dimension 1: state of departure
   # Dimension 2: state of arrival
   # Dimension 3: individual
   # Dimension 4: time

# 1. State process matrix
totrel <- sum(marked)
PSI.STATE <- array(NA, dim=c(n.states, n.states, totrel, n.occasions-1))
for (i in 1:totrel){
   for (t in 1:(n.occasions-1)){
      PSI.STATE[,,i,t] <- matrix(c(
      phiA*(1-psiAB), phiA*psiAB,     1-phiA,
      phiB*psiBA,     phiB*(1-psiBA), 1-phiB,
      0,              0,              1       ), nrow = n.states, byrow = TRUE)
      } #t
   } #i

# 2.Observation process matrix
PSI.OBS <- array(NA, dim=c(n.states, n.obs, totrel, n.occasions-1))
for (i in 1:totrel){
   for (t in 1:(n.occasions-1)){
      PSI.OBS[,,i,t] <- matrix(c(
      pA, 0, 1-pA,
      b * pB,  (1-b) * pB, 1-pB,
      0,  0, 1       ), nrow = n.states, byrow = TRUE)
      } #t
   } #i

# 3. Matrix with the initial state probabilities
PSI.INI <- array(NA, dim=c(n.states-1, totrel, n.occasions))
for (i in 1:totrel){
   for (t in 1:n.occasions){
      PSI.INI[1,i,t] <- psi
      PSI.INI[2,i,t] <- 1-psi
      }
   }

# 4. Assignment matrix at initial capture
OBS.INI <- array(NA, dim=c(n.states, n.obs, totrel, n.occasions))
for (i in 1:totrel){
   for (t in 1:n.occasions){
      OBS.INI[,,i,t] <- matrix(c(
      1, 0,  0,
      b,  1-b,  0,
      0,  0,  1       ), nrow = n.states, byrow = TRUE)
      } #t
   } #i

# Execute function
sim.me <- simul.me(PSI.STATE, PSI.OBS, PSI.INI, OBS.INI, marked)
CH.me <- sim$CH
#table(CH) # 0 = not seen, 1 = seen alive as egg, 2 = seen alive as nestling, 3 = seen alive in unknown state


# Compute vector with occasion of first capture
get.first <- function(x) min(which(x != 0))
f <- apply(CH.me, 1, get.first)

# Recode CH matrix: note, a 0 is not allowed in WinBUGS
# 1 = seen without disease, 2 = seen with disease, 3 = not seen
rCH <- CH.me          # Recoded CH
rCH[rCH == 0] <- 3


# Function to create initial values for unknown z
me.init.z.sim <- function(ch, f){
   g <- which(ch == 3)
   g <- c(g, which(ch == 4))
   states <- max(ch, na.rm = TRUE)
   known.states <- 1:(states-2)
   ch[g] <- sample(known.states, length(g), replace = TRUE)   
   for (i in 1:nrow(ch)){
      fi <- ch[i,f[i]]
      ch[i,1:f[i]] <- NA
      ch[i,f[i]] <- fi
      }
   return(ch)
   }


# Bundle data
jags.sim <- list(y = rCH, f = f, n.occasions = dim(rCH)[2], nind = dim(rCH)[1])

# Initial values
inits <- function(){list(mean.phi = runif(2, 0, 1), 
                         mean.psi = runif(2, 0, 1), 
                         mean.p = runif(2, 0, 1), z = me.init.z.sim(rCH, f))}  

# Parameters monitored
parameters <- c("mean.phi", "mean.psi", "mean.p", "mean.b", "mean.pi")


# MCMC settings
nc <- 3; nAdapt <- 100; nb <- 200; ni <- 500 + nb; nt <- 1  

# Call jagsUI
me.sim <- jags(jags.sim, inits, parameters, n.chains = nc, model.file = model.file,
           n.adapt=nAdapt, n.thin = nt, n.iter = ni, n.burnin = nb, parallel = T)

print(me.sim, digits = 3)


```

