
# Following example code from Kery & Schaub, implementing Conn & Cooch 2009

```{r}

#install.packages('rstudioapi')
# install.packages(c('rjags', 'jagsUI', 'R2OpenBUGS', 'dplyr', 'tidyr', 'reshape2', 'data.table', 'ggplot2', 'scales', 'knitr', 'stringr', 'lubridate', 'stats', 'zoo'))

library(rstudioapi)
library(rjags)
#library(R2jags) #seems to fight with jagsUI
library(jagsUI)
library(R2OpenBUGS)
library(dplyr)
library(tidyr)
library(reshape2)
library(data.table)
library(ggplot2)
#library(cowplot) 
library(loo)
library(scales)
library(knitr)
library(stringr)
library(lubridate)
library(stats) 
library(zoo)
library(magrittr)

path <- getActiveDocumentContext()$path 
setwd(dirname(path))
#print(getwd())

#setwd("~/Documents/SAFS/PigeonGuillemots")
#setwd("C:\\Nathan\\UW\\projects\\PigeonGuillemotNestSurvival\\data")

```

```{r data}
#load data from PiGu_JS_ME_setup.Rmd

effort <- read.csv("days_since.csv", header = T, stringsAsFactors = F)
effort[,1] <- as.numeric(effort[,1])

#long version of capture history, spread out so there is one row per nest per week per year
data_MEJS_wide <- read.csv("burrow_CH.csv", header = T, stringsAsFactors = F)
data_MEJS_wide[,5:18] <- round(data_MEJS_wide[,5:18], 0)

#combined from which to subsample 
all_dat <- data_MEJS_wide %>% bind_cols(effort)
all_dat <- all_dat[sample(nrow(all_dat), 20),]
data_MEJS_wide <- all_dat[,1:22]
effort <- all_dat[,23:dim(all_dat)[2]]

#matrix of just capture histories, weeks
dummy_day <- matrix(NA, dim(data_MEJS_wide)[1], 1)  #dummy day is NA for obs/data, 1 for z not entered
ch <- cbind2(dummy_day, as.matrix(data_MEJS_wide %>% select(-c(region, year, site, burrow_name))))

dummy_eff <- matrix(NA, dim(data_MEJS_wide)[1], 1) 
eff <- as.matrix(data.frame(cbind(as.numeric(dummy_eff), effort)))
#eff[is.na(eff)] <- 'NA'  #help, what to do with NAs between surveys?

#try some very very basic perfect data
sim_dat <- matrix(sample(c(1:3, NA), 1400, replace = T, prob = c(0.5, 0.05, 0.4, 0.1)), 
                  ncol = 14, nrow = 100)
sim_dat[,1] <- NA
sim_dat[,14] <- NA

sim_eff <- matrix(sample(c(6:7), 1400, replace = T), ncol = 14, nrow = 100)
# sim_eff[,1] <- NA
# sim_eff[,14] <- NA

eff <- sim_eff
ch <- sim_dat

```


```{r aug inits}
     
# Augment data
# nz <- 200
# CH.aug <- rbind(ch, matrix(3, nrow = nz, ncol = dim(ch)[2])) #3 for not seen
# 
# #augmented effort - not finished
# eff.aug <- rbind(eff, matrix(eff[1,], nrow = nz, ncol = dim(EFFORT_MEJS)[2], byrow=T))
# eff.aug <- eff.aug[,-1] #remove first column (dummy column), because detection goes off of t-1

get.first <- function(x) min(which(x < 3))
f <- apply(ch, 1, get.first)
#a <- match(Inf, f)
     
get.last <- function(x) max(which(x < 3))
l <- apply(ch, 1, get.last)

# latent z; all obs of 1,3,4 are unk state, NA
# 2 obs means state 3, chick
z.st <- ch
z.st[which(z.st != 2)] <- NA
z.st[which(z.st == 2)] <- 3

first.pv <- function(x) min(which(x == 3))
fpv <- apply(z.st, 1, first.pv)

last.pv <- function(x) max(which(x == 3))
lpv <- apply(z.st, 1, last.pv)

first.bv <- function(x) min(which(x == 2))
fbv <- apply(ch, 1, first.bv)

last.bv <- function(x) max(which(x == 2))
lbv <- apply(ch, 1, last.bv)

for (i in 1:dim(z.st)[1]) {
  if (fpv[i] != Inf) {
  z.st[i, (fpv[i]):lpv[i]] <- 3 #chick between pv observations
  }
}

# Initial z values -
#ch <- ch
js.me.init <- function(ch, f, l){
  inits <- z.st

  for(i in 1:dim(ch)[1]) { 
    if (f[i] != Inf) {
    inits[i, 1:(f[i]-1)] <- 1  #1 before first capture 
    if(l[i] < dim(ch)[2]){ #for all cases
     inits[i, (l[i]+1):dim(ch)[2]] <- rep(3, (dim(ch)[2]-l[i])) #3 from last obs to end
    }
    if(sum(ch[i,] == 2, na.rm = T) > 0){ #nests with observed prey delivery
       if(f[i] == min(which(ch[i,] == 2))){  #if first obs is a prey delivery
        inits[i, f[i]:l[i]] <- 3              #chick until end of study 
        if(f[i] > 2) inits[i, 2:(f[i]-1)] <- 2  #egg prior to chick; couldn't it be not entered as well?

       } else { #if first obs is burrow visit
        inits[i, f[i]:(min(which(ch[i,] == 2))-1)] <- 2 #egg between f[i] and first pv
        inits[i, min(which(ch[i,] == 2)):l[i]] <- 3 #chick from first pv to last observation
       }
    } else { #never detected a prey delivery
      if(sum(ch[i,] == 2, na.rm = T) == 0){      
        inits[i, f[i]:(max(which(ch[i,] == 1)))] <- 2 #egg for all occasions between first and last bv
      }
    }
    }
   } #i
  return(inits)
}

z.init = js.me.init(ch, f, l)
z.init[,1] <- NA #deterministic on dummy occasion
z.init[which(z.st == 3)] <- NA #deterministic, don't initialize where z is known as chick between pvs

###########
z <- z.st
y <- ch

```

```{r description}

# -------------------------------------------------
# Parameters:
# phiA: survival probability from egg to chick
# phiB: survival probability from chick to fledge
# psiAB: probability of transitioning from egg to chick
# pA: detection probability of egg burrow
# pB: detection probability of chick burrow
# b: conditional on there being a chick, probability of seeing just a burrow visit
# gamma: entry probability
# alpha: conditional on entry at occasion 1, probability burrow had a chick. alpha set to 0 for t>1. So if a burrow is initiated after day one, it must start as an egg burrow.  

# -------------------------------------------------
# States:
# 1 not entered
# 2 alive as egg
# 3 alive as chick
# 4 terminated; dead or fledged

# Observations:  
# 1 Burrow visit
# 2 Prey visit
# 3 not seen
# NA not observed - no survey that day
# -------------------------------------------------

```

```{r logit mod}

model_MEJS <- function () {

# Priors and constraints
#for (i in 1:n_ind) {
for (t in 1:(n.occasions-1)){
 #phiA[t] <- mean.phi[1]   # egg survival
 #logit(phiA[i, t]) <- mu.p
 logit(phiA[t]) <- mu.phi[1]
 logit(phiB[t]) <- mu.phi[2]
 gamma[t] ~ dunif(0, 1)    # Prior for entry probabilities at occasion t
 pA[t] <- mean.p[1]     # egg burrow detection
 pB[t] <- mean.p[2]     # chick burrow detection
 psiAB[t] <- mean.psiAB
 alpha[t+1] <- 0              #probability of entry as chick on occasion t>1 
} #t

b ~ dunif(0,1)            # prior for assignment probability
mean.psiAB ~ dunif(0,1)   # transition from egg to chick
alpha[1] ~ dunif(0,1)     # if enter at occasion 1, probability that entered as chick burrow
alphaKeep <- alpha[1]      # this is the only one we want to keep 

for (u in 1:2){
  mu.phi[u] ~ dnorm(0, 0.001) 
 #mean.phi[u] ~ dunif(0, 1)    # Priors for mean state-spec. survival
 mean.p[u] ~ dunif(0, 1)      # Priors for mean state-spec. recapture
}
est.phiA <- 1 / (1+exp(-mu.phi[1]))
est.phiB <- 1 / (1+exp(-mu.phi[2]))

# Likelihood 
for (i in 1:M){
 # Define latent state at first occasion
  z[i,1] <- 1            #all M individuals are in state 1 at t=1 (e.g., one day prior to season)
 for (t in 2:n.occasions){
  # State process: draw S(t) given S(t-1)
  z[i,t] ~ dcat(ps[z[i,t-1], i, t-1,])
  # Observation process: draw O(t) given S(t)
  y[i,t] ~ dcat(po[z[i,t], i, t-1,])  
   #this follows Kery and Schaub 10.3.2, y[i,2] is a function of state[i,2] and observation array t=1; if detection covariates are used, don't add dummy occasion to detection covariates as detection data at occasion t uses array t-1

  # Derived objects
  egg[i,t-1]    <- equals(z[i,t], 2)
  chick[i,t-1]  <- equals(z[i,t], 3)
  active[i,t-1] <- max(egg[i,t-1],chick[i,t-1]) #egg or chick
} #t
 everEgg[i]    <- max(egg[i,])
 everChick[i]  <- max(chick[i,])
 EverActive[i] <- max(everChick[i],everEgg[i])
} #i

#derive abundances 
 for (t in 1:(n.occasions-1)){
  N.egg[t]    <- sum(egg[1:M,t])
  N.chick[t]  <- sum(chick[1:M,t])
  N.active[t] <- sum(active[1:M,t])
  qgamma[t] <- 1-gamma[t]
  birthProb[t] <- cprob[t] / psi      # Entry probability
} #t

cprob[1] <- gamma[1]
 for (t in 2:(n.occasions-1)){
  cprob[t] <- gamma[t] * prod(qgamma[1:(t-1)])
 }#t
psi <- sum(cprob[])            # Inclusion probability

Nstar <- sum(EverActive[1:M])

# Define transition and observation matrices
 for (i in 1:M){
  for (t in 1:(n.occasions-1)) {
      # Define probabilities of state S(t+1) given S(t)   
      ps[1,i,t,1] <- 1-gamma[t]                    #probability of not entering
      ps[1,i,t,2] <- gamma[t]*(1-alpha[t])         #probability of entering as egg
      ps[1,i,t,3] <- gamma[t]*alpha[t]             #probability of entering as chick. Note: only alpha[1]>0
      ps[1,i,t,4] <- 0                             #probability of entering as terminated
      ps[2,i,t,1] <- 0                             #probability egg goes to 'not entered'
      #ps[2,i,t,2] <- (1-psiAB[t])*phiA[t]          #probability of surviving egg state and not transitioning
      ps[2,i,t,2] <- (1-psiAB[t])*(phiA[t]^eff[i,t])     
      #ps[2,i,t,3] <- phiA[t]*psiAB[t]              #probability of surviving egg state and hatching
      ps[2,i,t,3] <- psiAB[t]*(phiA[t]^eff[i,t])      
      #ps[2,i,t,4] <- 1-phiA[t]                      #probability of a failed egg
      ps[2,i,t,4] <- 1-phiA[t]^(eff[i,t])  #probability of a failed egg
      ps[3,i,t,1] <- 0                                #probability chick goes to 'not entered'
      ps[3,i,t,2] <- 0                                #probability chick goes to egg
      #ps[3,i,t,3] <- phiB[t]
      ps[3,i,t,3] <- phiB[t]^(eff[i,t])     #probability of surviving chick stage
      #ps[3,i,t,4] <- 1-phiB[t]               #probability of failed chick
      ps[3,i,t,4] <- 1-(phiB[t]^(eff[i,t]))  #probability of failed chick
      ps[4,i,t,1] <- 0                      #probability terminated goes to 'not entered'
      ps[4,i,t,2] <- 0                       #probability terminated goes to egg (maybe happens)
      ps[4,i,t,3] <- 0                       #probability terminated goes to chick
      ps[4,i,t,4] <- 1                       #probability terminated goes to terminated
      
      # Define probabilities of O(t) given S(t)
      po[1,i,t,1] <- 0                        #'not entered' burrow is detected with a burrow visit
      po[1,i,t,2] <- 0                        #'not entered' burrow is detected with a prey visit
      po[1,i,t,3] <- 1                        #'not entered' burrow is not detected
      po[2,i,t,1] <- pA[t]                    #egg burrow is detected with a burrow visit
      po[2,i,t,2] <- 0                        #egg burrow is detected with a prey visit
      po[2,i,t,3] <- 1-pA[t]                  #egg burrow is not detected
      po[3,i,t,1] <- b * pB[t]                #chick burrow is detected with a burrow visit 
      po[3,i,t,2] <- (1 - b) * pB[t]          #chick burrow is detected with a prey visit
      po[3,i,t,3] <- 1 - pB[t]                #chick burrow is not detected
      po[4,i,t,1] <- 0                        #terminated burrow is detected with a burrow visit
      po[4,i,t,2] <- 0                        #terminated burrow is detected with a prey visit
      po[4,i,t,3] <- 1                        #terminated burrow is not detected
  } #t
 }#M

}

write.model(model_MEJS, "model_MEJS.txt")
model.file = paste(getwd(),"model_MEJS.txt", sep="/")


```


```{r run}

# Bundle data
jags.data <- list(y = y, n.occasions = dim(ch)[2], 
                  z = z.st, 
                  eff = eff,
                  M = dim(ch)[1])

inits <- function(){list(#mean.phi = runif(2, 0, 1), 
                         z = z.init,
                         mean.p = runif(2, 0, 1))}  
     
# Parameters monitored
parameters <- c('est.phiA', 'est.phiB', "mean.phi", "mean.p", "b", "gamma", 
                "alphaKeep", "mean.psiAB", "N.egg", "N.chick",
                "N.active", "Nstar", "psi", "birthProb")
     
# MCMC settings
ni <- 100; nt <- 1; nb <- 5; nc <- 2
     
out_pigu <- jags(jags.data, inits, parameters, model.file = model.file,
              n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel = T)

#out <- readRDS('out_pigu.rds')

```

```{r}
     
#print(js_me, digits = 3)
# outmat<-as.matrix(js_me$samples)
# plot(apply(outmat[,grep("N.active\\[", colnames(outmat))],2,median), pch=16, type="b", ylab="Number", xlab=c("Day of season"))
# points(apply(outmat[,grep("N.egg\\[", colnames(outmat))],2,median), pch=16, type="b", col="red")
# points(apply(outmat[,grep("N.chick\\[", colnames(outmat))],2,median), pch=16, type="b", col="blue")
# legend("topleft", legend=c("Active","Egg", "Chick"), text.col=c("black", "red", "blue"), bty="n")

```

```{r plots}
#2 is nestling, 1 is egg, 3 is obs not seen, 0 is not observed
prey_del_plot_data <- data_MEJS_wide %>%
  filter(region == 'Whidbey')
prey_del_plot_data[is.na(prey_del_plot_data)] <- 0

 get.first.pv <- function(x) min(which(x == 2))
 first_pv <- apply(prey_del_plot_data, 1, get.first.pv)

 get.first.bv <- function(x) min(which(x == 1))
 first_bv <- apply(prey_del_plot_data, 1, get.first.bv)

 get.last.pv <- function(x) max(which(x == 2))
 last_pv <- apply(prey_del_plot_data, 1, get.last.pv)

 get.last.bv <- function(x) max(which(x == 1))
 last_bv <- apply(prey_del_plot_data, 1, get.last.bv)

 par(mfrow = c(2, 2), mar = c(5, 4, 2, 1), cex.lab = 1, cex.axis = .8)
 hist(first_pv, breaks = 81, main = '')
 hist(first_bv, breaks = 81, main = '')
 hist(last_pv, breaks = 81, main = '')
 hist(last_bv, breaks = 81, main = '')

 as.data.frame(table(first_pv))

 pv_minmax <- data_MEJS %>%
   filter(capt_hist == 2 & region != 'SS') %>%
   group_by(region, year, site, burrow_name) %>%
   summarize(min_pv = min(study_day), max_pv = max(study_day)) %>%
   rename(FirstPreyVisit = min_pv, LastPreyVisit = max_pv)

 bv_minmax <- data_MEJS %>%
   filter(capt_hist == 1 & region != 'SS') %>%
   group_by(region, year, site, burrow_name) %>%
   summarize(min_bv = min(study_day), max_bv = max(study_day))

 minsmax <- pv_minmax %>%
   bind_rows(bv_minmax) %>%
   melt(id.vars = c('region', 'year', 'site', 'burrow_name'))

 by_year <- ggplot(minsmax %>% filter(grepl("Prey", variable)), aes(factor(year), value), color = variable) +
   geom_boxplot() + facet_wrap(~variable) + coord_flip() +
   xlab("") + ylab("Study Day") +
   fig_theme()

 by_site <- ggplot(minsmax %>%
                    filter(grepl("Prey", variable) & value != 'NA' & region == 'Whidbey'),
                  aes(site, value)) +
   geom_boxplot() + coord_flip() +
   facet_wrap(~variable) +
   xlab("") + ylab("Study Day") +
   fig_theme(legend.position = 'none')

 # by_reg <- ggplot(minsmax %>%
 #                    filter(value != 'NA'),
 #                  aes(region, value, group = region, color = variable)) +
 #   geom_boxplot() +
 #   facet_wrap(~variable) +
 #   xlab("") + ylab("Study Day") +
 #   fig_theme(legend.position = 'none') +
 #   scale_color_manual(values = c("#3b98ee", "#a3d39c", "#e45f56", "#f6b61c"))

 density <- ggplot(data = data_MEJS, aes(study_day)) +
   geom_line(data = data_MEJS %>% filter(capt_hist == 1 & region != 'SS'), aes(study_day, col = 'BV'),
             stat = 'density') +
   geom_line(data = data_MEJS %>% filter(capt_hist == 2 & region != 'SS'), aes(study_day, col = 'PV'),
             stat = 'density') +
   #geom_vline(aes(xintercept = 40), linetype = 'dotted', col = 'darkgrey') +
   #geom_vline(aes(xintercept = 20), linetype = 'dotted', col = 'darkgrey') +
   scale_y_continuous(limit = c(0, 0.025)) +
   ylab("Relative Frequency Density") + xlab("Study Day") + 
   #facet_wrap(~region) +
   scale_color_manual(values = c("#e45f56", "#363e7e")) +
   fig_theme(legend.position = 'top')


 # capt_hist_day <- ggplot(data_MEJS %>% filter(region == 'Whidbey' & capt_hist < 3),
 #                 aes(y = capt_hist, x = study_day)) +
 #                 geom_point(position = 'jitter')

```

#####simulation from Nathan
```{r}

# Function to simulate capture-recapture data under a multi-event JS model; adapted from Kery & Schaub
   # Unobservable: number of unobservable states
n.occasions <- 82                        # Number of capture occasions
Nstar <- 500                             # Superpopulation size (total number of burrows active on at least one day)
n.states <- 4                            # not entered, egg, chick, terminated
n.obs <- 3                               # burrow visit, prey delivery, not detected
gamma <- c(0.5, seq(0.2, 0.01, length = n.occasions-1))      # Entry probabilities decrease with time
alpha <- c(.40, rep(0, n.occasions-1))   # Prob burrow is a "chick burrow" given entry (assume this only occurs on day 1)
phiA <- 0.8                              # survival state A (egg burrow)
phiB <- 0.7                              # survival state B (chick burrow)
psiAB <- 0.25                            # transition A to B conditional on survival
pA <- 0.5                                # detection for egg burrow
pB <- 0.75                               # detection for chick burrow
beta <- 0.25                             # conditional on observing chick, probability the delivery was a 'burrow visit'

#Define matrics

#state at entry
INIT.STATE <- matrix(NA,nr=n.occasions, nc=n.states) 
 for(t in 1:n.occasions){
  INIT.STATE[t,]<- c(0, 1-alpha[t], alpha[t], 0) #conditional on entry at time t, prob of entry as chick burrow 
 }

#state process conidtional on entry (survival and transition)
PHI.STATE <- array(NA, dim=c(n.states, n.states, Nstar, n.occasions))
for (i in 1:Nstar){
   for (t in 1:n.occasions){
      PHI.STATE[,,i,t] <- matrix(c(
      0,		  	0,        				0,   				0,     #this line is not needed since it is conditional on entry state
      0,           	phiA*(1-psiAB), 			phiA*psiAB,           	1-phiA,
      0,          	0,           			phiB, 			1-phiB,
      0,       		0,                    		0,            		1), nrow = n.states, byrow = TRUE)
      } #t
   } #i

#Observation process
P.OBS <- array(NA, dim=c(n.states, n.obs, Nstar, n.occasions))
for (i in 1:Nstar){
   for (t in 1:n.occasions){
      P.OBS[,,i,t] <- matrix(c(
      0,  0,  1,                   #not detected if not entered
      pA, 0,  1-pA,                #detection if egg burrow
      pB*beta,  pB*(1-beta), 1-pB, #detection if chick burrow
      0,  0,  1),                  #detection if terminated
      nrow = n.states, byrow = TRUE)
      } #t
   } #i

# Function to simulate capture-recapture data under the JS model
simul.js_ms_me <- function(PHI.STATE, P.OBS, Nstar, n.occasions, n.obs, n.states){

   z <- chTRUE <- matrix(0, ncol = n.occasions+1, nrow = Nstar) #true and observed processes including dummy occasion
   # Generate total number of entering burrows per occasion
   B <- rmultinom(1, Nstar, gamma) # Generate total number of entering burrows per occasion
   ent.occ <- numeric()
   for (t in 1:n.occasions){
      ent.occ <- c(ent.occ, rep(t+1, B[t])) #plus one to account for dummy occasion
   }

   # Simulating survival, transition, and detection
   for (i in 1:Nstar){
    #prior to entry
    z[i,1:(ent.occ[i]-1)] <- 1
    chTRUE[i,1:(ent.occ[i]-1)] <- n.obs #cannot be observed prior to capture

    #at entry occasion 
    for(t in ent.occ[i]){
     z[i,t] <-  which(rmultinom(1, 1, INIT.STATE[t-1,])==1) #state at entry occasion
     event <- which(rmultinom(1, 1, P.OBS[z[i,t],,i,t-1])==1)        #obs given state
     chTRUE[i,t] <- event
    }

    #after entry occasion
    if(ent.occ[i]<(n.occasions+1)){ #survival process if entered prior to end of study
     for(t in ent.occ[i]:n.occasions+1){
      z[i,t] <- which(rmultinom(1, 1, PHI.STATE[z[i,t-1],,i,t-1])==1) #state
      event <- which(rmultinom(1, 1, P.OBS[z[i,t],,i,t-1])==1)        #obs given state
      chTRUE[i,t] <- event
     }#t
    }#if
  }#i
   
   # Remove individuals never captured
   captured<-apply(chTRUE,1, min)<n.obs
   chOBS<-chTRUE[captured,]
   alive<-z
    alive[z==1|z==4]<-0
    alive[z==2|z==3]<-1
   Nt <- colSums(alive)    # Actual population size
   Negg <- Nchick <- NA
   for(t in 1:(n.occasions+1)){
    Negg[t]<-length(which(z[,t]==2))
    Nchick[t]<-length(which(z[,t]==3))
   }
   return(list(CH=chOBS, B=B, N=Nt, Negg=Negg, Nchick=Nchick))
}#funciton

# Execute simulation function
sim <- simul.js_ms_me(PHI.STATE, P.OBS, Nstar, n.occasions, n.obs, n.states)
CH <- sim$CH
 #verify
 sim$N
 sim$B
 sum(sim$B) #should equal simulated value of Nstar


# Add dummy occasion
#CH.du <- cbind(rep(1, dim(CH)[1]), CH)  #1 for not entered
     
# Augment data
nz <- 50
CH.aug <- rbind(CH, matrix(n.obs, nrow = nz, ncol = dim(CH)[2])) 

 get.first <- function(x) min(which(x < n.obs))
f <- apply(CH, 1, get.first)
get.last <- function(x) max(which(x < n.obs))
l <- apply(CH, 1, get.last)

#inits for state process z[i,t]
js.me.init <- function(ch, f, l, nz){
  inits <- matrix(NA, nr=dim(ch)[1], nc=dim(ch)[2])
  inits[,1] <- NA  #deterministic on occasion 1

  for(i in 1:dim(ch)[1]) { 
    inits[i,1:f[i]-1] <- 1  #1 before first capture 
    if(l[i]<dim(ch)[2]){
     inits[i, (l[i]+1):dim(ch)[2]] <- rep(3, (dim(ch)[2]-l[i])) #3 from last obs to end
    }
    if(sum(ch[i,] == 2, na.rm=T)>0){ #sites with observed prey delivery
       if(f[i]==min(which(ch[i,]  == 2))){  #if first obs is a prey delivery
        inits[i, f[i]:l[i]]<-3              #chick until end of study 
        if(f[i]>2) inits[i, 2:(f[i]-1)]<-2  #egg prior to chick

       }else{
        inits[i, f[i]:(min(which(ch[i,]  == 2))-1)]<-2
        inits[i, min(which(ch[i,]  == 2)):l[i]]<-3
       }
    }else{ #never detected a prey delivery
      if(sum(ch[i,] == 2, na.rm=T)==0){      
        inits[i, f[i]:(max(which(ch[i,]  == 1)))]<-2
      }
    }
   }#i
  return(inits)
}

zInitsObs <- js.me.init(CH, f, l, nz)
zInits<-rbind(zInitsObs,matrix(1,nr=nz, nc=dim(CH)[2]))
zInits[,1]<-NA #deterministic on first occasion

inits <- function(){list(mean.phi = runif(2, 0, 1), 
                         mean.p = runif(2, 0, 1), 
                         z = zInits)}    
#data
jags.data <- list(y = CH.aug, n.occasions = n.occasions+1 , M = dim(CH.aug)[1])
   
# Parameters monitored
parameters <- c("mean.phi", "mean.p", "beta", "gamma", "alphaKeep", "mean.psiAB","N.egg","N.chick",
                "N.active","Nstar","psi","b")

# MCMC settings
nc <- 3; nAdapt <- 500; nb <- 100;  ni <- 1000; nt <- 1

# Run
js_me <- jags(jags.data, inits, parameters, model.file = "model_JS_MS_ME.txt",
              n.chains = nc, n.adapt=nAdapt, n.thin = nt, n.iter = ni, n.burnin = nb, parallel=T)

plot(js_me$samples[,"alphaKeep"])

#abundances
outmat<-as.matrix(js_me$samples)
plot(apply(outmat[,grep("N.active\\[", colnames(outmat))],2,median), pch=16, type="b", ylab="Number", xlab=c("Day of season"), ylim=c(0,Nstar))
points(apply(outmat[,grep("N.egg\\[", colnames(outmat))],2,median), pch=16, type="b", col="red")
points(apply(outmat[,grep("N.chick\\[", colnames(outmat))],2,median), pch=16, type="b", col="blue")
legend("topleft", legend=c("Active","Egg", "Chick"), text.col=c("black", "red", "blue"), bty="n")
 #true values
 points(sim$N[2:(n.occasions+1)], pch=0)
 points(sim$Negg[2:(n.occasions+1)], pch=0, col="red")
 points(sim$Nchick[2:(n.occasions+1)], pch=0, col="blue")

#estimated 'birth' rates
plot(apply(outmat[,grep("b\\[", colnames(outmat))],2,median), pch=16, type="b", ylab="Probability", xlab=c("Day of season"), ylim=c(0,1))
 points(b, pch=0) #true values



```



```{r model prob scale}

model_MEJS <- function () {

# Priors and constraints
for (t in 1:(n.occasions-1)){
 phiA[t] <- mean.phi[1]   # egg survival
 phiB[t] <- mean.phi[2]   # chick survival
 gamma[t] ~ dunif(0, 1)    # Prior for entry probabilities at occasion t
 pA[t] <- mean.p[1]     # egg burrow detection
 pB[t] <- mean.p[2]     # chick burrow detection
 psiAB[t] <- mean.psiAB
 alpha[t+1] <- 0              #probability of entry as chick on occasion t>1 
}

b ~ dunif(0,1)            # prior for assignment probability
mean.psiAB ~ dunif(0,1)   # transition from egg to chick
alpha[1] ~ dunif(0,1)     # if enter at occasion 1, probability that entered as chick burrow
alphaKeep <- alpha[1]      # this is the only one we want to keep 

for (u in 1:2){
 mean.phi[u] ~ dunif(0, 1)    # Priors for mean state-spec. survival
 mean.p[u] ~ dunif(0, 1)      # Priors for mean state-spec. recapture
}

# Likelihood 
for (i in 1:M){
 # Define latent state at first occasion
  z[i,1] <- 1            #all M individuals are in state 1 at t=1 (e.g., one day prior to season)
 for (t in 2:n.occasions){
  # State process: draw S(t) given S(t-1)
  z[i,t] ~ dcat(ps[z[i,t-1], i, t-1,])
  # Observation process: draw O(t) given S(t)
  y[i,t] ~ dcat(po[z[i,t], i, t-1,])  
   #this follows Kery and Schaub 10.3.2, y[i,2] is a function of state[i,2] and observation array t=1; if detection covariates are used, don't add dummy occasion to detection covariates as detection data at occasion t uses array t-1

  # Derived objects
  egg[i,t-1]    <- equals(z[i,t], 2)
  chick[i,t-1]  <- equals(z[i,t], 3)
  active[i,t-1] <- max(egg[i,t-1],chick[i,t-1]) #egg or chick
} #t
 everEgg[i]    <- max(egg[i,])
 everChick[i]  <- max(chick[i,])
 EverActive[i] <- max(everChick[i],everEgg[i])
} #i

# Define transition and observation matrices
 for (i in 1:M){
  for (t in 1:(n.occasions-1)) {
      # Define probabilities of state S(t+1) given S(t)   
      ps[1,i,t,1] <- 1-gamma[t]                    #probability of not entering
      ps[1,i,t,2] <- gamma[t]*(1-alpha[t])         #probability of entering as egg
      ps[1,i,t,3] <- gamma[t]*alpha[t]             #probability of entering as chick. Note: only alpha[1]>0
      ps[1,i,t,4] <- 0                             #probability of entering as terminated
      ps[2,i,t,1] <- 0                             #probability egg goes to 'not entered'
      ps[2,i,t,2] <- (1-psiAB[t])*phiA[t]          #probability of surviving egg state and not transitioning
      #ps[2,i,t,2] <- (1-psiAB[t])*(phiA[t]^eff[i,t])     
      ps[2,i,t,3] <- phiA[t]*psiAB[t]              #probability of surviving egg state and hatching
      #ps[2,i,t,3] <- *psiAB[t]*(phiA[t]^eff[i,t])      
      ps[2,i,t,4] <- 1-phiA[t]                                #probability of a failed egg
      #ps[2,i,t,4] <- 1-phiA[t]^(eff[i,t])  #probability of a failed egg
      ps[3,i,t,1] <- 0                                        #probability chick goes to 'not entered'
      ps[3,i,t,2] <- 0                                        #probability chick goes to egg
      ps[3,i,t,3] <- phiB[t]
      #ps[3,i,t,3] <- phiB[t]^(eff[i,t])     #probability of surviving chick stage
      ps[3,i,t,4] <- 1-phiB[t]                                #probability of failed chick
      #ps[3,i,t,4] <- 1-(phiB[t]^(eff[i,t]))  #probability of failed chick
      ps[4,i,t,1] <- 0                                        #probability terminated goes to 'not entered'
      ps[4,i,t,2] <- 0                                        #probability terminated goes to egg (maybe happens)
      ps[4,i,t,3] <- 0                                        #probability terminated goes to chick
      ps[4,i,t,4] <- 1                                        #probability terminated goes to terminated
      
      # Define probabilities of O(t) given S(t)
      po[1,i,t,1] <- 0                        #'not entered' burrow is detected with a burrow visit
      po[1,i,t,2] <- 0                        #'not entered' burrow is detected with a prey visit
      po[1,i,t,3] <- 1                        #'not entered' burrow is not detected
      po[2,i,t,1] <- pA[t]                    #egg burrow is detected with a burrow visit
      po[2,i,t,2] <- 0                        #egg burrow is detected with a prey visit
      po[2,i,t,3] <- 1-pA[t]                  #egg burrow is not detected
      po[3,i,t,1] <- b * pB[t]                #chick burrow is detected with a burrow visit 
      po[3,i,t,2] <- (1 - b) * pB[t]          #chick burrow is detected with a prey visit
      po[3,i,t,3] <- 1 - pB[t]                #chick burrow is not detected
      po[4,i,t,1] <- 0                        #terminated burrow is detected with a burrow visit
      po[4,i,t,2] <- 0                        #terminated burrow is detected with a prey visit
      po[4,i,t,3] <- 1                        #terminated burrow is not detected
  } #t
 }#M

#derive abundances 
 for (t in 1:(n.occasions-1)){
  N.egg[t]    <- sum(egg[1:M,t])
  N.chick[t]  <- sum(chick[1:M,t])
  N.active[t] <- sum(active[1:M,t])
  qgamma[t] <- 1-gamma[t]
  birthProb[t] <- cprob[t] / psi      # Entry probability
}
 cprob[1] <- gamma[1]
 for (t in 2:(n.occasions-1)){
  cprob[t] <- gamma[t] * prod(qgamma[1:(t-1)])
 }#t
 psi <- sum(cprob[])            # Inclusion probability

Nstar <- sum(EverActive[1:M])

}

write.model(model_MEJS, "model_MEJS.txt")
model.file = paste(getwd(),"model_MEJS.txt", sep="/")


```
